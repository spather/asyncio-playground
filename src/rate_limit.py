"""Coding challenge generated by ChatGPT:
Problem Statement:

* Write an asynchronous Python function that makes API calls to a rate-limited service. The service allows you to make only 5 requests per second.
* The function should accept a list of API endpoints and query parameters, make the API calls concurrently while respecting the rate limit, and return their responses.
* Implement a mechanism to handle the rate limit without using external libraries.

Skills Tested: Understanding of asyncio for network I/O, rate limiting concepts, and implementing basic control flows in asynchronous code.
"""

import asyncio
import aiohttp

from typing import Any, Coroutine, Dict, List, Sequence


async def get_request(
    session: aiohttp.ClientSession, url: str, params: Dict[str, Any]
) -> Dict[str, Any]:
    try:
        async with session.get(url, params=params) as resp:
            if resp.status == 200:
                json = await resp.json()
                return {"type": "success", "json": json}
            else:
                return {"type": "http_error", "status": resp.status}

    except aiohttp.ClientConnectionError as ex:
        return {
            "type": "connection_error",
            "exception": ex,
        }


# Could also define co-routines for post_request, put_request, delete_request
# etc. to support other types of requests


async def make_requests_with_rate_limit(
    requests: Sequence[Coroutine[Any, Any, Dict[str, Any]]], rate_limit: int
):
    print(f"Got {len(requests)} requests with rate limit {rate_limit}")

    next_idx = 0
    in_flight_tasks: List[asyncio.Task] = []

    def done_callback(t: asyncio.Task):
        in_flight_tasks.remove(t)
        print(f"Task completed, {len(in_flight_tasks)} in flight")

    while next_idx < len(requests):
        if rate_limit - len(in_flight_tasks) > 0:
            task = asyncio.create_task(requests[next_idx])
            next_idx += 1
            in_flight_tasks.append(task)
            task.add_done_callback(done_callback)
            print(f"Created task, {len(in_flight_tasks)} in flight")
        else:
            await asyncio.wait(in_flight_tasks, return_when=asyncio.FIRST_COMPLETED)

    if len(in_flight_tasks) > 0:
        await asyncio.wait(in_flight_tasks, return_when=asyncio.ALL_COMPLETED)


async def main():
    async with aiohttp.ClientSession() as session:
        requests = [
            get_request(session, "http://httpbin.org/get", {}),
            get_request(session, "http://httpbin.org/get", {}),
            get_request(session, "http://httpbin.org/get", {}),
            get_request(session, "http://httpbin.org/get", {}),
            get_request(session, "http://httpbin.org/get", {}),
            get_request(session, "http://httpbin.org/get", {}),
            get_request(session, "http://httpbin.org/get", {}),
            get_request(session, "http://httpbin.org/get", {}),
            get_request(session, "http://httpbin.org/get", {}),
            get_request(session, "http://httpbin.org/get", {}),
        ]
        await make_requests_with_rate_limit(requests=requests, rate_limit=5)


if __name__ == "__main__":
    asyncio.run(main())
